# A

- 简单的观察

存在一个最优的方案，使得第 $i$ 个硬币开第 $i$ 个机器。

- 我们的最优策略会怎么样？

考虑访问硬币的顺序，显然是递增的。

所以每次我们都向右获取一些新硬币，然后返回打开这些硬币对应的机器。

- 一个小观察

如果第 $i$ 个机器在第 $i$ 个硬币右边，可以直接将硬币的位置移到机器的位置。

所以我们下文保证 $a_i\leq b_i$。

- 如何刻画这个过程？

使用 DP。

状态为开完前 $i$ 个机器，停在第 $i$ 个机器上的最小代价。

可以证明，存在最优解使得数轴上每个位置至多路过三次。每次转移一段这样的折线即可

所以，列出转移方程为 $f_i=f_{j}+(b_i-a_j)+(a_i+b_i-2a_{j+1})$。

直接做是 $O(n^2)$ 的。

将 $i$ 有关的部分和 $j$ 有关的部分分别整理即可，$O(n)$。

# B

这是一个经典技巧，DP时通过“一次转移多步”压缩转移来优化，降低所需要的状态数。

具体来说，我们可以得到一个DP：$f[i,j,k]$ 表示考虑前 $i$ 个数，最后两个数 $a_{i-1}=j,a_i=k$，满足这些条件的所有方案的前 $i-2$ 天疲劳度乘积之和。这个状态数是 $O(n^3)$。

如何优化呢？我们考虑到，实际上我们只关心每连续三个数 $a$ 的最大值。那么我们考虑在状态里只记录最大值。

例如，设 $g[i,j,k,l]$ 表示考虑前 $i$ 个数，且 $a_i=j$，且 $k=[a_i\ge a_{i+1}], l=[a_i\ge a_{i+2}]$ 的所有方案的前若干天（所有已经确定最大值的天数，如果 $k=l=1$ 就是到第 $i$ 天，否则 $k=1$ 就是到第 $i-1$ 天，否则到第 $i-2$ 天）疲劳度乘积之和。转移的时候只要满足限制就行。

注意不能只从 $i-1$ 转移到 $i$，会有问题，因为有可能 $a_{i-2}\lt a_{i-1} \lt a_i$，我们需要直接从 $g[i-2,\cdot,0,0]$ 转移到 $g[i,\cdot, \cdot ,\cdot]$。

如果只从 $i-1$ 转移到 $i$ 那状态数不可能低于 $n^3$ 级别，必须一次跨多个位置转移才能只记录最大值。这是一种DP的压缩转移的技巧。

这样我们把状态数优化到了 $O(n^2)$，再前缀和优化转移就是 $O(n^2)$ 的复杂度。

同类题目：CF1943D2

# C

矩阵显然是反对称的，也就是如果 $A_{i,j}=W/E$ 那么对应 $A_{j,i}=E/W$。所以我们**只考虑右上的半个矩阵**即可。以下所有的描述都只考虑右上部分。

可以证明，合法当且仅当满足以下两个条件：

- 不存在某个 $E$ 在某个 $W$ 的左下方。
- 不存在一个子序列 $1\le t_1\lt t_2\lt t_3\dots t_k \le n$ 使得序列内的相邻位置关系对（$A_{t_1,t_2}, A_{t_2,t_3}, \dots ,A_{t_k,t_1}$）出现两次 $E$ 的情况。

以上两个条件等价于：

- **$W,E$ 的分界线从矩阵的上边沿出发只向下和向右到右边沿结束，不穿过矩阵主对角线**
- **且分界线总长度不超过 $n$。**

直接DP计算方案数即可，时间复杂度是 $O(n^3)$。

# D

- 算法 1，$O(n^3m\log a)$

不说了。

期望得分 $8$。

- 算法 1+，$O(n^2m\log a)$

其实这是是 $O(n^2m+n\log a)$，因为只会有 $\log$ 次扩大 LCM 的过程。

期望得分 $16$。

- 算法 1++，$O(nm\log a\log n)$

注意到每个左端点的合法区间是一个连续段，二分后用线段树或 ST 表维护。

期望得分 $24$。 

- 算法 1+++，$O(nm\log a)$

使用双指针优化算法 1++ 即可。

期望得分 $32$。

- 算法 2，不支持修改，$O(n\log n\log a+m\log n)$。

显然在值域范围内，$\text{lcm}$ 只会被改变 $\log a$ 次，因为每次至少翻倍。

注意每个区间只能给 $\log a$ 个询问提供贡献，对于每个点都二分出所有区间即可。

结合算法 1+++ 期望得分 $48$。

- 算法 3，很多 $\log$

使用分治思想，开一棵线段树，对于每个节点计算所有跨越左右儿子的贡献。

这样的话修改一个元素的时间只需要重新计算线段树上 $\log n$ 个节点的值就可以了。

维护前后缀所有 $\text{lcm}$ 的时间复杂度为 $O(m\log a\log n)$。

然而每次计算要枚举左端点和右端点，时间复杂度高达 $O(m\log^2 a\log n)$。

结合算法 2 期望得分 $68$。

> 为什么这里不是 $O(\log^3 a)$ 呢？
> 考虑一个势能分析，插入每个质因数只需要 $O(1)$ 的时间。
> 分析的方法和 $\gcd$ 差不多。

- 算法 4

典中典之随机数据！

首先全部输出 $0$ 是过不了的，因为还是有一定概率随到序列里的数的。

然后你发现一个长度超过 $3$ 的区间几乎没有合法的概率，因此向两段扫几个数就可以了。

结合算法 1+++ 和算法 2 期望得分 $64$。

结合算法 2 和算法 3 期望得分 $84$。

- 算法 5

你发现你线段树学傻了。

每个点的贡献其实只有 $\log^2 a$ 级别，即考虑它左侧 $\log$ 个 $\text{lcm}$ 和右侧 $\log $ 个 $\text{lcm}$。

我们考虑回到前面的算法，如果我们动态地维护区间 $\text{lcm}$，我们可以通过线段树二分，$O(m\log n\log a)$ 直接算出这些 $\text{lcm}$。

**注意不要在线段树上每访问一个节点就计算 $\text{lcm}$，先判断 $\text{lcm}$ 改变再计算，否则辗转相除算出 $\gcd(a,b)=b$ 虽然是 $O(1)$ 的，但是常数非常大。**

这样的时间复杂度就只有 $O(m\log^2 a+m\log n\log a)$ 了，期望得分 $100$。
